<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Shano Moodle</title>
</head>
<body>
<script>

  // PASTE THE FOLLOWING SCRIPT IN THE CONSOLE

  const URL = 'https://learn.fmi.uni-sofia.bg/';
  const TEXT = `
За коя от изброените групи не са предназначени системните изисквания?
Клиенти
<br><br>
Компютърните системи обикновено са много скъпи защото:
Създаването на софтуер е процес, който изисква значителни усилия.
<br><br>
Коя от изброените не е допълнителна рамкова дейност от софтуерния процес?
планиране
<br><br>
Кое от следните твърдения е причина думата "инженерство" да е част от термина "софтуерно инженерство"?
Разработването на софтуер включва анализ на изискванията, проектиране, реализиране и тестване както създаването на конвенционален инженерен продукт.
<br><br>
Кое от изброените не е предимство при програмирането по двойки (pair programming)?
Повишава скоростта на разработване
<br><br>
В стилът неявно извикване (implicit invocation), компонентите взаимодействат помежду си чрез:
Изпращане на т.нар. събития, при които изпращащия компонент не знае нищо за получателя.
<br><br>
Поддръжката на софтуера се смята за важен атрибут на качествения софтуер защото:
През жизнения цикъл на софтуера в много случаи повече пари се отделят за проддръжка, отколкото за първоначалното разработване на софтуера.
<br><br>
Изисквания, които се променят, поради промени в средата, в която работи организацията се наричат:
Мутиращи изисквания
<br><br>
Кои от изброените не са цели на UML?
Да предостави средства за управление на процеса на разработване
Да се създаде използваем език за хора и машини
<br><br>
Кои от следните твърдения са верни за софтуерната архутектура?
Резултат е от фазата на дизайн в процеса за разработка на софтуерни системи.
Съществени елементи на модулната структура на архитектурата са не само компонентите, които носят функционалността, но и свръзващите ги модули.
<br><br>
Кои от следните се класифицират като елементарен тип данни в езиците за програмиране?
byte
int
<br><br>
Structured text е специфичен програмен език за реализация на вградени системи, който наподобява Паскал.
Истина
<br><br>
Допълнителните рамкови дейности на софтуерното инженерство се прилагат само по време на началните фази от процеса на разработване на софтуер.
Лъжа
<br><br>
Коя от изброените не е допълнителна рамкова дейност от софтуерния процес?
планиране
<br><br>
Софтуерна система е почти завършена, когато се открива грешка. Цената за корегиране на грешката ще бъде най-висока, ако грешката е направена по време на:
Имплементация
<br><br>
Какво включва документацията на софтуерната архитектура?

<br><br>
За кое от следните може да се твърди че представлява софтуерен компонент?

<br><br>
Кое от изброените не е дейност при управление на качеството?

<br><br>
При гъвкавите софтуерни процеси, най-високият приоритет е да се удовлетвори клиента, чраз ранно и непрекъснато доставяне на ценен (valued) софтуер.

<br><br>
Кое не е дейност при управлението на риска?

<br><br>
Моделът на бързата/стръмната разработка е:

<br><br>
Системите за реално време със синхронно диспечиризиране се характеризира с:

<br><br>
Операционните системи за реално време задължително имат следните функции:

<br><br>
Кое от изброените не е част от плана на качеството?

<br><br>
Софтуерът се влошава, а не се износва защото:

<br><br>
Тестването на системата е достатъчно, за да се гарантира нейната надежност.

<br><br>
Създаването на софтуер чрез еволюционен прототип включва:

<br><br>
Кои твърдения не са верни?

<br><br>
Коя от изброените дейност не е основна при инженеринга на изискванията:

<br><br>
Кое от следните е вярно при т.нар плътен (fat) клиент?

<br><br>
Идеята за междинното ниво (в разпределените системи) е въведена за:

<br><br>
За коя от изброените групи не са предназначени системните изисквания?

<br><br>
Ако трябва да опишете взаимодействието между различни обекти в системата по отношение на времето, каква диаграма бихте използвали?

<br><br>
Кои от тези стратегически въпроси трябва да се адресират при успешен процес на тестване на софтеур?

<br><br>
Тестване което цели да изпита системата отвъд максималното натоварване по дизайн и да се предизвика срив на системата се нарича:

<br><br>
Практически не е възможно да се разработят софтуерни системи, в които не съществуват грешки в кода (бъгове).

<br><br>
Кои от изброените не са верни при тестването при гъвкавата методология XP? (три верни отговора)

<br><br>
Прототипният модел на разработване на софтуер е:

<br><br>
Функционалното изискване към софтуерната система е:

<br><br>
Кое от изброените не е характерно за неформалните групи/екипи?

<br><br>
Моделно-ориентираната разработка е:

<br><br>
За какво се използва протоколът SOAP При уеб-услугите?

<br><br>
При кой от следните модели на софтуерен процес времето до възможността за обратна връзка от клиента е най-бързо?

<br><br>
Вградените софтуерни системи се реализират и изпълняват върху програмируеми логически контролери но не и върху едночипови микрокомпютри.

<br><br>
Кое от следните не се класифицира като е диаграма на поведението в UML?

<br><br>
За кои от изброените понятия се счита че осъществяват многократна употреба в обектно-ориентирания дизайн?

<br><br>
Кои от изброените не са верни за управлението на качеството?

<br><br>
По какво се различават изключенията от тип faults и aborts?
За faults се знае коя инструкция ги е причинила и програмата или процесът могат да бъдат рестартирани без загуба, докато при aborts това може да не е ясно и следва прекратяване на програмата или процесът. Изключенията от тип грешки (fault) като цяло могат да бъдат коригирани и затова след като се случат и бъде изпълнена обработващата програма, се стартира отново същата програма (която е генерирала грешката), като се счита, че грешката вече е коригирана (от обработващата програма). За изключенията от тип abort не винаги се знае коя инструкция ги е предизвикала и не позволяват рестартиране на програмата или процесът, които ги причиняват. Използват се за регистриране на хардуерни грешки или недопустими стойности в системни таблици.
<br><br>
Каква информация се съдържа в Task-Register и за какво се използва?
Task Register (TR) - съдържа 16 битов сегментен селектор, както и допълнителна част, в която автоматично се зарежда съдържанието на съответния дескриптор. Това включва базов адрес (32 бита в защитен и 64 бита в IA-32e режим), размер на сегмента и атрибути наTask State Segement (TSS) на текущия процес. Селекторът реферира TSS дескриптор в глобалната таблица GDT. Когатозапочне изпълнението на нов процес (Task) съдържанието на дескриптора се зарежда в скритата час и едва когато се смени процесът, то тогава се променя и сегментния регистър. По този начин, при следващо обръщение (в рамките на същата задача), не е необходимо да се достъпва глобалната таблица. Когато обаче се смени сегментния селектор е необходимо отново да се заредят данните от съответния дескриптор и да се запишат в скритата част (Segment Descriptor Registers).
<br><br>
Какво представлява и каква е функцията на челната част (Front End)?
Челната част се състои от fetch/decode unit, execution trace cache. Челната част извлича и декодира инструкциите. Декодираните инструкции се транслират до микрооперации (μops). Основната задача на тази часте да осигурява непрекъснат поток от микрооперации на изпълняващата част.
<br><br>
Опишете полетата, обособяващи формата на инструкциите при Intel архитектурите.
Дадена инструкция е разделена на няколко елемента: 
1) Instruction prefixes – отразяват се на поведението на операциите които трябва инструкцията да извърши.
2) Opcode – може да бъде един или повече байта (до три цели байта). 
3) ModR/M байт – не задължителен и понякога може да съдържа част от opcode (кодът на операцията). 
4) SIB байт – не е задължителен и представлява комплексни индиректни паметни форми. 
5) Displacement – отместването не е задължително и е стойност с варираща големина от байтове (byte, word, long). 
6) Immediate – не е задължителен компонент и се използва като числова стойност от вариращи размери от байтове (byte, word, long).
<br><br>
Какъв е приоритетът на прекъсванията? RS232, DISK
<br><br>
Какви класове инструкции знаем?
FPL инструкции (плаваща запетая)
SSE
MMX
SSE2
SMXI
<br><br>
Какво е характерно за регистрите с общо предназначение при 64-битов режим?
Регистрите с общо предназначение се използват за да съдържат операнди. 64 битовият режим позволява работа с 32 и 64 битови операнди, като по подразбиране се използват 32 битови операнди. При работа с 32 битови операнди се използват регистрите EAX, EBX, ECX, EDX, EDI, ESI, EBP, ESP, R8D - R15D. При работа с 64 битови операнди, пред обикновената (32 битова) инструкция се поставя REX префикс и регистрите са съответно: RAX, RBX, RCX, RDX, RDI, RSI, RBP, RSP, R8- R15. Т.е. REX се използва за генериране на 64 битови операнди.
<br><br>
Какво е характерно за адресното пространство (при някоя конкретна архитектура)?
Режим на работа, Protected mode, Сегментация, Странициране
1)	Линейното адресно пространство директно се изобразява върху физическото адресно пространство.  Линейното адресно пространство е виртуално – извършва се странична преадресация; страниците имат размер 4KB.
2)	В архитектурите IA-32 и Intel-64 са вградени два механизма за организация на виртуалната памет – сегментация (segmentation) и странициране (paging). В така наречения защитен режим могат да се използват и двата механизма за адресация
3)	При сегментацията адресът се получава от 16-битов сегментен регистър и 32-битово отместване
4)	При 4KB страници за адресиране на 4 GB линейно адресно пространство са необходими 220 страници.
<br><br>
Как се изчислява адресът?
modR/M байтът осигурява най-удобния от методите за адресиране. За операндите които се намират в паметта дефинирани от modR/M отместването във желания сегмент се пресмята като се сумират до три компонента: • displacement елемент в инструкцията. • базов регистър (base register). • индексен регистър (index register). Индексния регистър може автоматично да бъде умножен по scaling factor – 2, 4 или 8. Отместването което се получава от събирането на тези компоненти се нарича ефективен адрес. Всеки един от тези компоненти на ефективния адрес може да има и положителна 2 и отрицателна стойност. Ако сумата на всички тези компоненти превиши 232 , ефективния адрес се трансформира в 32 бита.
<br><br>
Адресиране на операнди при IA-32 и INTEL-64
Операндите в паметта се реферират чрез сегмент и отместването в него. При 32 битовия режим адресът на операнда се състои от 16 битов сегментен селектор и 32 битово отместване в сегмента. При 64 битовия режим, сегментния селектор също е 16 бита, но отместването може да бъде до 64^2.
<br><br>
Опишете сегемнтните регистри и тяхното предназначение
Сегментните регистри са 6 и остават 16 битови. Тяхното предназначение е да съхраняват сегментен селектор. Има различни сегменти. CS – (Code Segment) – съдържа базовия адрес на сегментът, в който се съхранява програмата. DS – (Data Segment) – съдържа адреса на сегмента, в който се съхраняват данните. SS – (Stack Segment) ES – (Extra Data Segment) – допълнителен сегмент за данни. FS - Допълнителен сегмент за данни. GS - Допълнителен сегмент за данни.
<br><br>
Опишете полетата на флаговия регистър
AF (Auxiliary Carry Flag) - междинен пренос (междинен пренос между младшата и страшата тетрада). Смисъла от този флаг е някоя от следващите инструкции да провери този флаг. Използва се при двоично кодиране на десетични числа.
SF(Sign flag) – най-левия бит на резултата (знака).
OF (Overflow flag) - за препълване ако и двата са нула или и двата са единица нямаме препълване. Ако се различават то имаме такова.
DF (Direction flag) – обикновено при сравнение на низове (обръщане на посоката на прочитане на данните). Този флаг може да се постави от приложната програма (разрешен е за пипане от всяка програма).
TF (Trap Flag) – когато се сложи в единица се изпълнява една инструкция и се прави трап. Режим на трасировка.
IF (Interrupt Enable Flag) – за да се случи прекъсване този флаг трябва да е единица.
IOPL (I/O Privilege Level) – ниво на привилегия на входно изходните устройства. От това се определя дали да се случи едно входно изходнопрекъсване или не.
AC (Alignment Check) – когато се сложи в единица се задължава процесора да прави проверка за подравняването на границите на операндите. Ако е е в нула процесора не се интересува къде са границите.
ID (ID flag) – идея всеки процесор да си има собствен идентификатор. Това не е този идентификатор, но при този флаг в единица се позволява да се ползва този идентификатор.
Status Flags - Статус флаговете на EFLAGS регистъра позволяват резултатите от една инструкция да влияят на следващи инструкции. Аритметичните инструкцииизползват OF, SF, ZF, AF, PF и CF. SCAS (Scan String), CMPS (Compare String) и LOOP инструкците използват ZF за да сигнализират, че са свършили работата си.
Control Flag - Контролният флаг DF от регистъра EFLAGS контролира инструкциите с низове.
<br><br>
Опишете режимите на адресация при IA-32 и Intel-64
x86-64 процесор се държи като IA-32 процесор когато е включен в реален или защитен режим. Това са режими които се поддържат когато процесора не е в long режим. Докато големината на регистрите е увеличена до 64-бита в сравнение с предишната x86 архитектура, адресирането на паметта все още не е увеличено до пълните 64 бита. Поради това, load/store unit(s), cache tags, MMUs и TLBs могат да бъдат по-прости без никаква загуба на използваема памет.
<br><br>
Опишете основните типове данни
- Байт, дума, двойна дума, четворна дума и двойна четворна дума са фундаменталните типове данни. Integer - Знакова двоична числова стойност; Unsigned Integer - Беззнакова двоична числова стойност; Floating point – Формат с плаваща запетая; Near pointer - 32-битов логически адрес; Far pointer - 48-битов логически адрес от два компонента: 16-битов сегментен селектор и 32-битово отместване; Bit field - Последователност от битове. Битово поле може да започне от всяка позиция и всеки байт и може да съдържа до 32 бита; BCD -  кодиране на всяка десетична цифра на число като набор от четири бита. При това всеки байт на числото съдържа една или две десетични цифри в така наречения двоично-десетичен код (BCD — Binary-Coded Decimal); SIMD data types.
<br><br>
Какво представлява и какви са предимствата на пакетираните SIMD типове данни?
SIMD(Single–Instruction Multiple–Data) – подход, който използва алгоритм за работа с мултимедийни данни, който се базират на паралелното изпълнение на една операция над няколко числа.  
MMX (Multi-Media eXtension) – технологията е разработена за да ускори мултимедийните програми и програмите за комуникация като включват нови инструкции и типове данни които позволяват на програмите да достигат ново ниво на производителност.
<br><br>
Представете схема на паметта при big endian и little endian записване на данните. Пояснете схемата.
Big-endian - старшият байт е първи.
Little-endian - при нея първи е младшият байт.
При Little-endian с увеличаването на адреса се увеличава старшинството (значимостта, порядъкът) на байтовете. При Big-endian е точно обратното.
<br><br>
Какво представлява и какви са предимствата на пакетираните SIMD типове данни?
SIMD(Single–Instruction Multiple–Data) – подход, който използва алгоритм за работа с мултимедийни данни, който се базират на паралелното изпълнение на една операция над няколко числа.  
MMX (Multi-Media eXtension) – технологията е разработена за да ускори мултимедийните програми и програмите за комуникация като включват нови инструкции и типове данни които позволяват на програмите да достигат ново ниво на производителност.
<br><br>
Опишете полетата, обособяващи формата на инструкциите
1) Instruction prefixes – Чрез префикса може да се променя поведението на инструкцията, като например да се сменя сегмента, размера на думата, да се управлява цикличното изпълнение и използването на шината
2) Opcode – Кодът на операцията се кодира с 1, 2 или 3 байта. Допълнително може да се използват и 3 бита от полето ModR/M. Използването на тези полета зависи в голяма степен от типа операцията.
3) ModR/M байт –не задължителен и понякога може да съдържа част от opcode-а.
4) SIB  – – Scaled Index Base,не е задължителен 
5) Displacement – Размерът на отместването се определя от полето Mod на ModR/M байта
6) Immediate - не е задължителен компонент и се използва като числова стойност от вариращи размери от байтове(byte, word, long).
<br><br>
Опишете режимите на адресация и ролята на modR полето
Специфицира регистъра, в който е записан (първия??) операнд.
<br><br>
За какво и как се ползва префиксът?
Чрез префикса може да се променя поведението на инструкцията, като например да се сменя сегмента, размера на думата, да се управлява цикличното изпълнение и използването на шината. Има няколко групи префикса, всяка група може да е 1 байт (общо една група може да е 4 байта или 0).
<br><br>
Поведение на REX prefix?
Към формата на инструкцията в 64 битов режим  се добавя REX префикс.  REX префикса съдържа битове, които разширяват ModR/M полетата. По този начин ще работят и старите и новите програми, които използват повече регистри.
<br><br>
Приложения на управляващи регистри
Управляващите регистри се използват от операционната система. Те са 32 битови във всички 32 битови режими. В 64 битов режим системните регистри са 64 битови. CR0 - Съдържа флагове контролиращи режимите на работа и състоянието на процесора. CR1 — Запазен, но не се използва. CR2 – Съдържа линейния адресът, който е причина за изключение от тип „page fault“. CR3 (PDBR) - Съдържа физическия адрес на таблицата със страници на текущия процес, както и флаговете PCD и PWT. CR4 - Съдържа група от флагове позволяващи използването на различни разширения.
<br><br>
Какво е характерно за защитния режим?
Защитения режим се контролира от управляващи регистри (Control Registers), които са означени CR0, CR2, CR3 и CR4.
Защитен режим е режим на работа на компютърните процесори в архитектурата x86. При защитения режим, максималната адресирана памет е 4 GB (232 байта), има 'странициране' и 'сегментиране' на паметта, както и апаратна защита на достъпа до паметта и входно-изходното пространство. Почти всички съвременни операционни системи за x86 процесори работят изключително в защитен режим.
<br><br>
Предназначения на сегментните селектори
Сегментните селектори са 16 битови идентификатори на сегмента. Старшите 13 бита се използват за определяне на отместването в глобалната или локалната дескрипторни таблици. Трите младши бита имат по-специфично предназначение
<br><br>
Механизъм на обновяване на страница от диск
Мениджърът на паметта използва информацията от таблиците за да намери неизползвана страница физическа памет (такава, към която скоро не е имало обръщения) и я записва в резервирана област на диска, наречена swap файл. После уведомява централния процесор за необходимостта да прочете изискваната страница от по-бавната памет (файл на диска или swap файл). Накрая MMU установява съответствието между виртуалната и физическата страница и обновява таблицата с тази информация.
<br><br>
Какво представлява сегментирането на паметта? Предимства и недостатъци
При сегментацията адресът се получава от 16-битов сегментен регистър и 32-битово отместване. Регистърът EIP е 32-битов и в него се записва отместването относно началото на кодовия сегмент, а регистърът ESP е 32-битов и в него се записва адресът на върха на стека, зададен като отместване относно началото на стековия сегмент. Всеки от останалите 32-битови общи регистри може да се използва за задаване на отместване при адресация на данни в някой от сегментите за данни
<br><br>
Обяснете преобразуването на логическия адрес във физически при сегментно страничната организация на паметта
В режим на сегментация и странициране получаваме 32-битов линеен адрес. Първите 10 бита от него се умножават по ширината на полето на каталога (4 bytes) и се добавят към началния адрес на каталога. Ако старшият бит на реда в каталога е 1, значи че съществува каталог в паметта, който се сочи от реда в каталога. В такъв случай се взимат младшите 20 бита от реда в каталога, добавят им се 12 нули отдясно и се прибавя стойността на полето PN, умножена по широчината на реда в каталога. В реда в каталога (в младшите му20 бита) е записан адресът на търсената от нас страница, ако тя съществува. Последните 20 бита на реда в каталога съдържат линейния адрес на страницата, а физическият адрес на нейното начало се получава, като отново към тези 20 бита прибавим 12 нули отдясно и се прибави 12-битовият offset.
<br><br>
Какви полета съдържа локалната дискрипторна таблица?
LDT – Локална Дескрипторна Таблица е таблица в оперативната памет, в която се разполага на части потребителската програма (всяка част е на отделен ред от таблицата). Всеки ред от тази таблица се нарича дескриптор. Адресът се задава с двойки регистри – сегментен регистър и отместване или сегментен регистър  и регистър-база. Винаги е 16-битов, като десният бит показва дали се адресира спрямо ЛДТ или ГДТ. В два бита се кодира какъв режим се използва. Остават 13 бита – едно число, което е отместване в дескрипторната таблица
<br><br>
Каква информация се съдържа в task register
16-битовия сегментен селектор и целия сегментен дескриптор на текущата задача (32-битов базов адрес, 16-битова граница на сегмента и атрибути на дексриптора). Тази информация се копира от TSS-дескриптора в GDT за текущата задача.
<br><br>
Как се осъществява преобразуването на линеен адрес към 4 –KB стр с използване на 32-битово странициране
При този метод за адресиране може да се адресират до 220 страници, което прави 232 байта или 4GB. За да се избират различните редове от таблицата, линейният адрес се разделя на четири секции: • Ред в таблицата на главния каталог (битове от 30 и 31) – съдържа се отместването на всеки от четирите реда в таблицата на главния каталог. Избраният ред задава съответния физически адрес на каталога. • Ред в каталога (битове от 21 до 29) – съдържа се отместването на всеки от редовете в таблицата на каталогa. Избраният ред задава съответния физически адрес на каталога. • Ред в таблицата на страниците (битове от 12 до 20) – съдържа се отместването на всеки от редовете в таблицата на страниците. Избраният ред задава съответния физически адрес на страницата във физическата памет. • Отместване в страницата (битове от 12 до 20) – съдържа се отместването на физическия адрес в съответната страница.
<br><br>
Обяснете структурата на задачата при IA 32 архитектура
Задачата се състои от пространство за изпълнение (execution space) и сегмент за състоянието на задачата (Task State Segment TSS). Пространството за изпълнение се състои от сегмент за кода, стека и няколко сегмента за данни. Най-общо казано, TSS съхранява в паметта информацията, необходима за изпълнението (execution space) на дадена задача.
<br><br>
Обяснете функцията на task register
Регистърът на задачата (TR) съдържа 16-битовия сегментен селектор и целия сегментен дескриптор на текущата задача (32-битов базов адрес, 16-битова граница на сегмента и атрибути на дексриптора). Тази информация се копира от TSS-дескриптора в GDT за текущата задача.
<br><br>
Как се осъществява превключването на задачите?
Когато бъде назначено изпълнението на дадена задача, става автоматично превключване между текущо изпълняваната задача и новоназначената задача за изпълнение. При превключването към друга задача, състоянието на средата, в която се е изпълнявала текущата задача се запазва в TSS и изпълнението на задача се прекратява за някакъв период от време. След това информацията за предстоящата за изпълнение задача се зарежда в процесора и нейното изпълнение започва от инструкцията, сочена от вече зареденият регистър EIP на текущата задача.
<br><br>
Каква информация се съдържа в IDT?
Interrupt Descriptor Table (IDT) e таблицата на векторите на прекъсванията. Тя има 256 елемента. Векторите на прекъсванията не са дескриптори на сегменти, а са входове към такива.
<br><br>
Обяснете групите, на които се делят изключенията
aborts, faults, traps
-trap e изключение, при което, след като се изпълни съответната програма за обработка, броячът на инструкциите се увеличава и сочи следващата инструкция.
-fault като цяло могат да бъдат коригирани и за това след като се случат и бъде изпълнена обработващата програма, се стартира отново същата програма (която е генерирала грешката), като се счита, че грешката вече е коригирана (от обработващата програма).
-abort не винаги се знае коя инструкция ги е предизвикала и не позволяват рестартиране на програмата или процесът, които ги причиняват.
<br><br>
По какво се различават изключенията от тип faults от тип aborts?
Изключенията от тип грешки (fault) като цяло могат да бъдат коригирани и за това след като се случат и бъде изпълнена обработващата програма, се стартира отново същата програма (която е генерирала грешката), като се счита, че грешката вече е коригирана (от обработващата програма).
За изключенията от тип abort не винаги се знае коя инструкция ги е предизвикала и не позволяват рестартиране на програмата или процесът, които ги причиняват. Използват се за регистриране на хардуерни грешки или недопустими стойности в системни таблици.
<br><br>
Каква е фунцкията на челната част?
Челната част извлича и декодира инструкциите. Декодираните инструкции се транслират до микрооперации (μops). Основната задача на тази част е да осигурява непрекъснат поток от микрооперации на изпълняващата част.
<br><br>
Каква е ролята на завършващата част?
Завършващата част се грижи резултатът от изчисленията да съответства на реда на постъпване на инструкции и че състоянието на системата се обновява правилно.
<br><br>
Как работи изпълняващата част?
Изпълняващата част пренарежда микрооперациите по такъв начин, че тези чиито операнди са готови (и има налични изчислителни ресурси) да се изпълнят възможно по - скоро. Изпълняващата част може да обработи (issue) няколко микрооперации за един цикъл.
<br><br>
Обяснетеп принципа на работа на кеш-паметта и протоколите за процесори
Кеш-паметта представлява структура, състояща се от множество от рамки (frames). Всяка рамка се състои от данни, етикет (tag) и състояние. Етикетът е характеристика на рамката, която е съществена при търсене в данните в кеша. Състоянието е два бита – бит valid, който показва дали данните в кеша са валидни и бит dirty, който показва дали в рамката са били писани данни. Търсенето и зареждането на рамки в кеша става по следния начин: проверява се дали входящият етикет съвпада с етикета на рамката. Ако не съвпадат, рамката не се намира (cache-miss) и в такъв случай блокът данни в рамката се изхвърля и се заменя с блок от по-долното ниво в йерархията, а след това блокът се подава на предното ниво в йерархията.
Протокол на кеша MESI:  използва се както в едноядрени, така и в многоядрени процесори. При този протокол се проверяват четири дефинирани състояния на всяка линия на кеша – (Modified, Exclusive, Shared, Invalid).
<br><br>
Какво представлява и как работи предварителното извличане?
Предварителното извличане на данните в кеша (Cache prefetching) е техника, която увеличава производителността, като копира данните от бавна памет в по-бърза, още преди да са необходими. Най-често се използват потокови буфери (Stream buffers), които се основават на последователното изпълнение на инструкциите и извличане на данните.
`;

  document.body.innerHTML = `
     <style>
        ::-webkit-scrollbar {
          display: none;
        }
      </style>
      <iframe src="${URL}" width="100%" height="100%"></iframe>
      <div id="shano-box" style="position: absolute; bottom: 5px; right: 21px;">
        <input type="checkbox" id="panic" onchange="onPanic(this)" style="opacity: 0.21"/>
        <div id="text-box" style="overflow:scroll; height:300px; width:300px; opacity: 0.3">
          ${TEXT}
        </div>
      </div>
  `;

  document.querySelector('html').style.height = '100%';
  const body = document.querySelector('body');
  body.style.height = '100%';
  body.style.overflow = 'hidden';
  body.style.margin = '0';
  body.style.padding = '0';
  document.querySelector('#panic').checked = true;
  const textBox = document.querySelector('#text-box');

  function onPanic(checkbox) {
    if (checkbox.checked) {
      textBox.style.visibility = 'visible'
    } else {
      textBox.style.visibility = 'hidden'
    }
  }

  // SCRIPT END

</script>
</body>
</html>
